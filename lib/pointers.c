#include <stdio.h>

int main(void) {

  int num = 15;
  printf("numという変数のアドレスは：%p\n", &num);
  printf("指定子も違うから注意が必要です\n");

  char str[100];
  printf("配列（文字も含めて）への代入は&が要らない。\n");
  printf("なぜかというと、配列の名前はアドレスを指すからです。\n");
  printf("だから、scanfをする時に、&strをする必要はない。\n");
  printf("でも、１つの要素を変えるなら、１つの変数として扱われているから「&」をつけないといけない。\n");
  printf("文字列を書きなさい：");
  /* 最初は普通の代入 */
  scanf("%s", str);
  printf("%sを入力しましたね\n", str);
  printf("もう一回文字列を入力してください：");
  /* 今回は&を使う */
  scanf("%s", &str[0]);
  printf("%sを入力しましたね\n", str);
  /* 要するに同じことですね */

  /*
   * 次のは「苦しんで覚えるC言語」の２９７ページからです（ポインタは２つのモードがあると）
   *
   *  ポインタ変数モードでは、たいした機能は備えていません。具体的には、アドレスへの代入と
   * 足し算引き算だけしかありません。なぜなら、ポインタ変数モードに必要なのはアドレスの記憶
   * だけだからです。アドレスさえ記憶していれば、後は特に何にもする必要がありません。
   *  通常変数モードに切り替わった場合、その性質は通常変数と全く同じになります。
   * おかげで、通常の変数と同様にさまざまな演算子を使って計算することができます。
   * 当然、その時に使われるメモリは、ポインタ変数モードで記憶したアドレスになります。
   *  今までの変数は、ただ通常変数として使えば良かったのですが、
   * ポインタ変数では、２つのモードを適切に切り替えて、使い分けなくてはいけないことを
   * 覚えておいてください。
   *
   */

  int *p_example;
  /* 次のように宣言もできます */
  int* p_example2;
  /* 要注意：尚、次の宣言仕方だと、最初の変数だけがポインタになります */
  int* p3, p4, p5;
  
  int *p;
  int i;
  p = &i;
  printf("p  = %p\n", p);
  printf("&i = %p\n", &i);
  /* p = NULL;  これは「0」と違います。if(p == NULL){}みたいな書き方ができます */

  /* 通常変数モード！ */
  *p = 10;
  printf("*p = 10;をしましたので、iも変わりました\n");
  printf("iの値がポインタによって変えられました：%d\n", i);

  /* 302ページ：
   *
   * 直接、何番のメモリを書き換えろ、と指定するのではなくて、書き換えたいメモリ
   * のアドレスを代入し、モードを切り替えて書き換える、という、いわば２段構えに
   * なっているため、直感的にはわかりにくいかもしれません。
   *
   */

  /* 303ページ
   * ここがややこしいのですが、通常変数モードに切り替える間接参照演算子*と、
   * 宣言の時に使用する*の記号は、なんの関係もないまったく別の記号です。
   */

  /* 304ページ
   * ポインタの本当の使い方は、ショートカットとして使用することです。
   * Windowsのテスクトップに並んでいる、あのショートカットと同じです。
   */


  return 0;

}


